Ordenamiento y tiempo son dos aspectos diferentes de consistencia de objectos compartidos en sistemas distribuidos. Uno evita conflictos entre operaciones, el otro dice que tan rápido los efectos de una operación son percibidos por el resto del sistema. 

\paragraph{\textnormal{\textbf{Consistency Criteria:}}}
La historia global \texttt{H} de un sistema distribuido es un conjunto parcialmente ordenado de todas las operaciones que ocurren en todos los sitios del sistema. \texttt{H}$_i$ es la secuencia de operaciones que son ejecutadas en el sitio $i$. Si $a$ ocurre antes que $b$ en \texttt{H}$_i$ decimos que $a$ precede a $b$ en orden de programa. Se asume que todas las operaciones en \texttt{H} son \textbf{read} o \textbf{write}. A estas operaciones les toma un tiempo finito ejecutarse, por lo tanto, hay un intervalo que va desde el momento cuando un \textbf{read} o un \textbf{write} ``inicia'' al momento cuando alguna de estas operaciones ``finaliza''. Sin embargo, para los propósitos de la \textit{timed consistency}, se asocia un instante a cada operación llamada el tiempo efectivo (\textit{effective time}) de la operación. El \textit{effective time} de una operación corresponde a algún instante entre su inicio y si fin. Si el tiempo efectivo de $a$ es $t$, se dice que $a$ fue ``ejecutado'' en el tiempo $t$. Si \texttt{D} es un conjunto de operaciones, entonces la serialización de \texttt{D} es una secuencia linear $S$ conteniendo exactamente todas las operaciones de \texttt{D} tal que cada operación \textbf{read} para un objecto particular retorna el valor que fue escrito por la operación \textbf{write} más reciente. Sea $\sim$ una relación de orden parcial arbitraria definida sobre \texttt{D}, decimos que la serialización $S$ ``respeta $\sim$'' si $\forall a, b \in$ \texttt{D} tal que $a \sim b$, pasa que $a$ precede a $b$ en $S$. La historia \texttt{H} satisface \underline{linealización} (\textbf{LIN}) si hay una serialización de \texttt{H} que respeta el orden inducido por los tiempos efectivos de las operaciones. \underline{Serialización estricta} se define sobre historias formadas por transacciones y requere de la existencia de una serialización de \texttt{H} que respete el orden de tiempo real de las transacciones. \underline{Normalidad} es equivalente a \textbf{LIN} cuando operaciones en objectos son unarias, pero es estrictamente más débil que \textbf{LIN} cuando las operaciones pueden abarcar varios objectos. Un nivel más débil de consistencia es ofrecido por \underline{consistencia secuencial} (\textbf{SC}). Este modelo, no garantiza que una operación \textbf{read} retorna el valor más reciente con respecto al tiempo real sino solo que el resultado de cualquier ejecución sea el mismo como si las operciones en todos los sitios fuera ejecutados en orden secuencial, y las operaciones de cada sitio individual aparecen en esta secuencia en el orden especificado por su programa. La historia \texttt{H} satisface \textbf{SC} si hay una serialización de \textbf{H} que respete el orden del programa para cada sitio en el sistema. \underline{La relación de causalidad} ``$\to$'' para sistemas de paso de mensajes puede ser modificada para ordernar las operaciones de \texttt{H}. Sea $a, b$ y $c \in$ \texttt{H}, se dice que $a \to b$ ($a$ precede causalmente a $b$) si se da una de las siguientes: (i) $a$ y $b$ son ejecutados en el mismo sitio y $a$ es ejecutado antes que $b$, (ii) $b$ lee el valor de un objeto escrito por $a$, (iii) $a \to c$ y $c \to b$. Dos operaciones distintas $a$ y $b$ son concurrentes is ninguna de estas condiciones se dan entre ellas. Sea \texttt{H}$_{i+w}$ el conjunto de todas las operaciones en \texttt{H}$_i$ más todas las operaciones \textbf{write} en \texttt{H}. La historia \texttt{H} satisface consistencia causal (\textbf{CC}) si para cada sitio $i$ existe una serialización de \texttt{H}$_{i+w}$ que respete el orden causal ``$\to$''. Así, si $a, b, c \in$ \texttt{H} son tales que $a$ escribe un valor \textbf{\texttt{v}} en el objeto \texttt{X}, $c$ lee el mismo valor \textbf{\texttt{v}} del objeto \texttt{X}, y $b$ escribe el valor \textbf{\texttt{v'}} en el objeto \texttt{X}, nunca se da el caso que $a \to b \to c$. \textbf{CC} require que todas las relaciones relacionadas con causalidad sean vistas en el mismo order por todos los sitios, mientras que diferentes sitios pueden percibir operaciones concurrentes en órdenes diferentes. \textbf{CC} es un modelo de consistencia más débil que \textbf{SC} pero puede ser implementado eficientemente.

\paragraph{\textnormal{\textbf{Timed Consistency}}}
Ni en \textbf{SC} ni en \textbf{CC}, el tiempo real es explícitamente capturado. En \textbf{SC}, operaciones puede aparecer fuer de orden en relación con sus tiempos efectivos. En \textbf{CC}, cada sitio puede ver operciones de escritura concurrente en diferente orden. Por otro lado, \textbf{LIN} requere que las operaciones sean observadas en un orden que respete su ordenamiento de tiempo real. \underline{\emph{Timed consistency}} requiere que si el tiempo efectivo de un \textbf{write} es $t$, el valor escrito por esta operación tiene que estar visible a todos los sitios en el sistema distribuido en el tiempo $t + \Delta$, donde $\Delta$ es un parámetro de ejecución. Se puede ver que cuando $\Delta$ es 0, \emph{timed consistency} se convierte en \textbf{LIN}\footnote{\emph{Timed Consistency} es una generalización (o un debilitamiento) de \textbf{LIN}}. \underline{\emph{Reading on Time:}} en modelos basados en tiempo, el conjunto de los valores que un \textbf{read} puede retorna está restringuido por la cantidad de tiempo que ha transcurrido a partir de los \textbf{write} que le preceden. Un \textbf{read} ocurre \underline{a tiempo} (\emph{on time}) si no devuelve datos obsoletos cuando hay valores más recientes que han estado disponibles por más de $\Delta$ unidades de tiempo. Esta definición depende las propiedades del reloj usando para assignar marcas de tiempo (\emph{timestamps}) a las operaciones en ejecución. Primero, se asume relojes físicos perfectamente sincronizados en donde $T(a)$ es el instante en tiempo real correspondiente al tiempo efectivo de la operación $a$. \textbf{Definición 1:} Sea \texttt{D} $\subseteq$ \texttt{H} un conjunto de operaciones y $S$ una serialización de \texttt{D}. Sea $w, r \in $ \texttt{D} tal que $w$ escribe un valor dentro de un objeto \texttt{X} que luego es leído por $r$ ($w$ es la operación \textbf{write} más cercana dentro del objeto \texttt{X} que aparece a la izquierda de $r$ en la serialización $S$). Se define el conjunto \texttt{W}$_r$ asociado con $r$ como: \texttt{W}$_r = \{w' \in$ \texttt{D} : ($w'$ escribe un valor dentro del objeto \texttt{X}) $\wedge (T(w) < T(w') < (T(r) - \Delta))\}$. Se dice que la operación $r$ ocurre o lee a tiempo en la serialización $S$ si \texttt{W}$_r = \varnothing$. $S$ es \emph{timed} si cada operación \textbf{read} en $S$ occurre a tiempo. \underline{\emph{Approximately-syncronized real-time clocks:}} En relojes de tiempo real aproximadamente sincronizados, resincronizaciones periódicas garantizan que no hay dos relojes difieran en más de $\varepsilon$ unidades de tiempo. Típicamente también se garantiza que la diferencia entre cualquier reloj y el tiempo ``real''\footnote{Mantenido por un servidor de tiempo} nunca es mayor que $\varepsilon/2$. De esta forma, si el tiempo efectivo de una operación $a$ fue reportada por un sitio en particular como $T(a)$, entonces, desde el punto de vista del servidor de tiempo, este tiempo efectivo corresponde a algún instance en el intervalo $[T(a) - \varepsilon/2, T(a) + \varepsilon/2]$. Se dice que $\forall a, b \in$ \texttt{H}, $a$ definitivamente ocurrió antes de $b$ si $T(a) + \varepsilon/2 < T(b) - \varepsilon/2$, o, de forma equivalente si $T(a) + \varepsilon < T(b)$. Si ni $a$ ni $b$ definitivamente ocurrieron antes que el otro, se se dice que sus marcas de tiempo son no comparales o concurrentes. Sea $w, r \in$ \texttt{D} $\subseteq$ \texttt{H} tal que $w$ escribe un valor dentro del objecto \texttt{X} que luego es leído por $r$. Dejar que $w' \in$ \texttt{D} actualice también el valor del objeto \texttt{X}. Si $T(w')$ definitivamente ocurrió antses que $T(w)$, o si $(T(r) - \Delta)$ ocurrió definitivamente antes que $T(w')$, entonces el claro que $w'$ no afecta el hecho que $r$ ocurra a tiempo. Ahora, si ambos $T(w')$ y $T(w)$ son concurrentes, o si $(T(r) - \Delta)$ y $T(w)$ son concurrentes, entonces no hay evidencia que $w'$ sea más reciente que $w$, o de $w'$ ocurriendo en más de $\Delta$ unidades de tiempo real antes que $r$ respectivamente. En estos casos, aun se puede argumentar que $r$ ocurre a tiempo. \textbf{Definición 2:} sea \texttt{D} $\subseteq$ \texttt{H} un conjunto de operaciones y $S$ una serialización de \texttt{D}. Sea $w, r \in$ \texttt{D} como se presenta en la definición 1. Se asume un conjunto \texttt{W}$_r$, asociado con $r$ como: \texttt{W}$_r = \{w' \in$ \texttt{D} : ($w'$ escribe un valor dentro del objeto \texttt{X}) $\wedge (T(w) + \varepsilon < T(w')) \wedge (T((w')) \wedge (T(w') + \varepsilon < T(r) - \Delta)\}$. Se dice que una operación $r$ ocurre o lee a tiempo en la serialización $S$ si \texttt{W}$_r = \varnothing$. $S$ es \emph{timed} si cada operación de \textbf{read} en $S$ ocurre a tiempo.

\section{¿Cuál es el problema que plantea el \textit{paper}?}

\section{¿Por qué el problema es interesante o importante?}

\section{¿Qué otras soluciones se han intentado para resolver este problema?}
     
\section{¿Cuál es la solución propuesta por los autores?}

\section{¿Qué tan exitosa es esta solución?} 