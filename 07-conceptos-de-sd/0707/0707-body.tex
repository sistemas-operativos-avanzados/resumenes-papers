Se describe una nueva forma de garantizar repetición determinista en multiprocesadores accesibles. Este método combina sencillez y el bajo \emph{overhead} en la grabación de registro de un programa \emph{multithreaded} en un uniprocesador con la velocidad y la escalabilidad de ejecución de un programa en un multiprocesador. La idea básica es que se peude usar un mecanismo más simple y rápido de grabación y repetición en un solo procesador y aún así lograr la escalabilidad ofrecida por múltiples núcleos, utilizando una ejecución adicional para paralelizar la grabación y la repetición de una aplicación. La meta es que una ejecución en un solo procesador sea tan rápida como una ejecución en paralelo tradicional, pero mantener la facilidad de registro de la ejecución \emph{multithreaded} de un solo procesador.

\paragraph{\textnormal{\textbf{Uniparallelism}}}
Es una técnica para lograr los beneficiones de ejecución en un solo procesador al mismo tiempo que se permite a la aplicación escalar con el aumento de procesadores. Una ejecución uniparalela consiste de ejecución \emph{thread-parallel} y ejecución \emph{epoch-parallel} del mismo programa; esto permite el uso de técnicas que corren solo en un uniprocesador. A diferencia de una ejecución tradicional \emph{thread-parallel} que escala con el número de núcleos corriendo diferentes \emph{threads} en diferentes núcleos, una ejecución \emph{epoch-parallel} logra escalabilidad de una manera diferente, corriendo diferentes epochs (segmentos de tiempo) de la ejecución en múltiples núcleos. Por lo tanto, ejecución \emph{epoch-parallel} requiere de la habilidad de predecir el estados del programa futuros; tales predicciones son generadas corriendo la segunda ejecución \emph{thread-parallalel} concurrentemente. Consecuentemente, para cargas de trabajo intensivas en CPU, la ejecución uniparalela requiere del doble del número de núclos de una ejecución tradicional, conduciendo a un aumento de aproximadamente 100\% de la utilización de CPU y energía. Uniparalalelismo mejora el rendimiento en dos casos: (1) si una carga de trabajo no es intensiva en CPU o si la aplicación no puede escalar y utilizar todos los núcleos eficientemente en una computadora \emph{multicore}, el costo de uniparalelismo puede ser mucho menos que del 100\%(típicamente menos de 20\%). (2) cuando la propiedad que se proporciona es más del doble de costosa en un multiprocesador que en un uniprocesador, es más eficiente en términos de tiempo y energía correr la aplicación dos veces con uniparalelismo que proporcionar la propiedad directamente en la versión multiprocesador de la aplicación.

\paragraph{\textnormal{\textbf{Design Overview}}}
La meta de DoublePlay es la de grabar eficientemente la ejecución de un proceso o group de procesos que corren en un multiprocesador tal que la ejecución pueda ser repetida de forma determinista luego todas las veces necesarias. DoublePlay corre dos ejecuciones simultaneas del programa que se está grabando. La ejecución \emph{thread-parallel}, corre múltiples \emph{threads} concurrentemente en los núcleos asignados para ello. DoublePlay particiona la ejecución \emph{thread-parallel} en segmetos de tiempo llamados \emph{epochs}. Al inicio de cada epoch, DoublePlay crea un punto de verificación \emph{copy-on-write} del estado de la ejecución \emph{thread-parallel}. La ejecución \emph{epoch-parallel} corre cada epoch en uno de los núcleos asignados para ello. Todos los \emph{threads} de un epoch dado corren en el mismo núcleo, lo que simplifica la tarea de repetir de forma determinista el resultado de la ejecución. Durante la grabación, DoublePlay guarda tres elementos que son suficientes para garantizar que la ejecución de un proceso puede ser repetido de forma determinista en el futuro. (1) Graba el estado inicial del proceso al inicio de la grabación. (2) DoublePlay graba el orden y los resultado de los \emph{system calls}, señales y sincronizaciones de bajo nivel en GNU \texttt{libc}. (3) graba la planificación de la ejecución del \emph{thread} de la ejecución \emph{thread-parallel}. Las dos ejecuciones puede ser vistas de la siguiente forma. La ejecución \emph{epoch-parallel} es la ejecución real del program que está siendo grabado. La ejecución \emph{epoch-parallel} corre en un solo núcleo. DoublePlay puede usar el mecanismo de repetición determinista uniprocesador para grabar y reproducir su ejecución. La ejecución \emph{thread-parallel} permite a la ejecución \emph{epoch-parallel} escalar de acuerdo al número de núcleos. La ejecución \emph{thread-parallel} proporciona un \emph{hint} en cuanto a lo que el estado futuro de la ejecución del proceso será en cada transición de epoch. Mientras que este \emph{hint} sea correcto, el estado del proceso al inicio de cada epoch en la ejecución \emph{epoch-parallel} coincidirá con el estado del proceso al final del epoch previo. Esto significa que los epochs se pueden juntar para forma una sola y natural ejecución del proceso. Si el estado de la ejecución \emph{epoch-parallel} ha divergido del estado de la ejecución \emph{thread-parallel}, DoublePlay aplasta (\emph{squaches}) la ejecución de todos los epochs subsecuentes para ambas ejecuciones. Restaura el estado de cada ejecución \emph{thread-parallel}  al punto de verificación en el inicio de cada epoch y reinicia ambas ejecuciones desde este punto. Las salidas no pueden ser externalizadas hastas que todos los epochs previos han sido encontrados como libres de divergencia. DoublePlay usa \emph{online  replay} para reducir la frecuencia de tales divergencias y sus resultantes atrasos. La única situacio4n en que la ejecución \emph{thread-parallel} y la ejecución \emph{epoch-parallel} podrían divergir es cuando el programa contiene un \emph{data race} y dos \emph{threads} se ejecutan sin sincronizar, haciendo que operaciones entren en conflicto en un espacio de memoria compartido. En cualquier momento subsecuente, DoublePlay puede repetir una ejecución grabada al (1) restaurar el estado inicial del proceso grabado, (2) repitiéndolo en un sólo núcleo usando los \emph{sistem calls} registrados, señales y operaciones de sincronización y (3) usa la misma planificación de la ejecución del \emph{thread} que fue usada durante la ejecución \emph{epoch-parallel}.

\paragraph{\textnormal{\textbf{Implementación}}}
La implementación de DoublePlay aprovecha el trabajo previo de Respec para proveer repetición \emph{online} determinista. Respec asegura que dos ejecuciones concurrentes del mismo proceso son externamente deterministas, lo que significa que las dos ejecuciones ejecutan los mismo \emph{system calls} en el mismo orden y que el estado del programa de los dos procesos es idéntico al final de cada epoch de ejecución. Respec sólo asegura determinismo externo mientras dos procesos se ejecutan al mismo tiempo. No aborda repetición determinista de un proceso luego de que la ejecución original se completa. \textbf{Supporting offline replay:} DoublePlay hace varias mejoras en la infraestructura básica de Respec con el fin de soportar repetición \emph{offline}. \textbf{Enabling concurrent epoch execution:} DoublePlay hace múltiples copias de la ejecución \emph{thread-parallel} llamando la primitiva de \emph{multi-threaded fork} antes de inicar la ejecución la ejecución de cada epoch individual. Esta primitiva crea un nuevo proceso cuyo estado es idéntico al de la ejecución \emph{thread-parallel} en el punto de su ejecución. Cada vez que un nuevo proceso es creado, DoublePlay no le permite iniciar su ejecución, sino que en lugar de esto, lo pone en un \emph{epoch queue} ordenada por el tiempo de creación del proceso. El \emph{scheduler} de DoublePlay es el responsable de decidir cuando y donde cada proceso va a correr. No hay garantía que la ejecución de un epoch finalizará en orden, debido a que algunos epochs son más cortos que otros . DoublePlay usa un algoritmo adaptativo para variar la longitud de los epochs. Aunque los epochs pueden finalizar no ordenados, DoublePlay asegura que ellos hacen \emph{commit} o \emph{rollback} en orden secuencial. Cuando un epoch completa su ejecución, DoublePlay realiza un \emph{divergence check} comparando su memoria y registros de estado con los del punto de verificación asociado con el próximo epoch. Cuando la verificación pasa, DoublePlay le permite al proceso salir y asigna su procesador a otro epoch. Cuando falla, DoublePlay finaliza todos los \emph{threads} que ejecutan el epoch actual y cualquier epoch futuro en la ejecución \emph{epoch-parallel}, así como todos los \emph{threads} de la ejecución \emph{thread-parallel}. \textbf{Replaying thread schedules:} DobulePlay garantiza repetición \emph{offline} determinista al ejecutar cada epoch en un solo núcleo usando la misma planificación de \emph{thread} que fue usada durante la grabación de la ejecución \emph{epoch-parallel}. Una estrategia es usar el mismo planificador determinista durante la ejecución \emph{epoch parallel} y la repetición \emph{offline}. La segunda estrategia es la de registrar las decisiones de planificación hechas durante la ejecución \emph{epoch parallel} y repetir aquellas deciciones de manera determinista durante la repetición \emph{offline}. Para la primera estrategia, se asigna una prioridad estricta a cada \emph{thread} basado en el orden en que los \emph{threads} fueron creados. DoublePlay siempre escoge el \emph{thread} con la prioridad más alta que preserve el orden total de los \emph{system calls} y el orden parcial de las operaciones de sincronización. Para permitir apropiaciones \emph{preemptions} se implementa la segunda estrategia para repetir la planificación de los \emph{threads} de forma determinista, la cual es la de registrar las apropiaciones que ocurren durante la ejecución \emph{epoch parallel} y repetir esas decisiones de forma determinista durante la repetición \emph{offline}. \textbf{Offline replay:} DoublePlay graba los \emph{system calls} y las operaciones de sincronización ejecutadas durando un epoch en un conjunto de archivos de bitácora. Luego de que cada epoch es \emph{committed}, DoublePlay marca las entradas que pertenecen a cada epoch como elegibles para ser escritas en disco. Luego escribe los registros marcados de forma asincrónica mientras otros epochs se ejecutan. Nótese que DoublePlay solo tiene que grabar los resultados de operaciones de sincronización o \emph{system calls}, ya que los argumentos a esas llamadas serán reproducidas de forma determinista por cualquier proceso de repetición. DoublePlay guarda el estado inicial del proceso cuando la grabación inicia. Para realizar una repetición \emph{offline}, inicia desde esta copia inicial. DoublePlay corre la repetición \emph{offline} en un solo procesador y usa un algoritimo de planificación (el de la sección anterior) para restringuir el orden de la ejecución del \emph{thread} para el proceso de repetición \emph{offline}. Cuando un \emph{thread} de repetición \emph{offline} ejecuta un \emph{system call} o una operación de sincronización, DoublePlay retorna los resultados grabados en su archivo de bitácora. DoublePlay solamente ejecuta \emph{system calls} que modifican el espacio de direcciones del processo como \texttt{mmap2} y \texttt{clone}. DoublePlay entrega las señales grabadas en el mismo punto en la ejecución del proceso en la que fueron entregadas durante la grabación. \textbf{Forward recovery:} Una vez que se vió que la ejecución \emph{epoch-parallel} como la que se tenía que ser grabada, fue claro que el estado de su ejecución en el momento de un fallo de verificación de divergencia es un estado válido de ejecución que puede ser reproducido \emph{offline} de forma determinista. Por lo tanto, DoublerPlay puede usar el estado del proceso \emph{epoch-parallel} en el momento de un fallo de verificación de divergencia como un punto de verificación de donde reiniciar la ejecución. A este proceso se le llama recuperación hacia adelante (\emph{forward recovery}). DoublePlay registra una operación para deshacer cada \emph{system call} que modifica el estado del kernel, así recuperación hacia adelante (o normal) puede devolver el estado del kernel al aplicar las operaciones para deshacer. \emph{Forward recovery} garantiza que DoublePlay haga progreso hacia adelante incluso cuando una verificación de divergencia falla. Todo el trabajo hecho por la ejecución \emph{epoch-parallel} hasta la verificación de divergencia, incluyendo al menos un \emph{data race}, será preservado. En el peor caso, cada epoch puede contener \emph{data races} frecuentes y verificaciones de divergencia que siempre fallen. \emph{Looser divergence checks:} con la implementación de \emph{forward recovery}, se decidió que realizar verificaciones estrictas de divergencia no era lo mejor. Se modificó DoublePlay par soportar tres tipos de formas más relajadas de verificación de divergencia en un epoch. (1) si el búfer circular de un \emph{thread} contiene un \emph{system call} sin ningún efecto hacia el exterior de este \emph{thread}, se permite omitir el registro extra en el búfer. (2) si un \emph{thread} ejecuta un \emph{system call} que produce una salida para un dispositivo externo, como una pantalla o una red, se permite que la ejecución \emph{epoch-parallel} ejecute el mismo \emph{system call} con diferente salida. (3) si un \emph{thread} ejecuta un conjunto de operaciones de sincronización \emph{self-canceling} o \emph{system calls} durante la ejecución \emph{thread-parallel}, entonces todos los miembros de ese conjunto pueden ser saltados. Beneficios de \emph{looser divergence}. (1) la ejecución \emph{epoch parallel} puede correr por más tiempo antes que se necesite un \emph{rollback}. (2) a veces un \emph{rollback} puede ser evitado en conjunto cuando la divergencia del estado proceso del proceso es transitoria. \textbf{Reverse scheduling:} la idea detrás de \emph{reverse scheduling} es la de intentar evitar \emph{rollbacks} cuando una verificación de divergencia falla al encontrar una planificación diferente cuya ejecución cause que la verificación pase. Así, cuando una verificación falle, DoublePlay corre otra ejecución \emph{epoch-parallel} del epoch fallido en el procesador asignado para ese epoch, pero usa las prioridades de planificación opuestas de las que se usaron por la ejecución fallida. Esto es, el último \emph{thread} creado tiene la prioridad más alta, no la más baja. La idea es que si hay un solo \emph{data race} en el epoch, entonces tanto la planificación normal o la reversa son muy probables a reproducir el mismo estado del programa producido por la ejecución \emph{thread parallel}. Si una segunda ejecución pasa la verificación de divergencia, el epoch es \emph{committed} y ningún \emph{rollback} ocurre. La planificación reversa del \emph{thread} es grabada en la bitácora de DoublePlay asi puede ser usada también durante la repetición.


\section{¿Cuál es el problema que plantea el \textit{paper}?}

\section{¿Por qué el problema es interesante o importante?}

\section{¿Qué otras soluciones se han intentado para resolver este problema?}
     
\section{¿Cuál es la solución propuesta por los autores?}

\section{¿Qué tan exitosa es esta solución?} 