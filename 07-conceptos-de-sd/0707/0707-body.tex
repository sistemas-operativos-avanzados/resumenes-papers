Se describe una nueva forma de garantizar repetición determinista en multiprocesadores accesibles. Este método combina sencillez y el bajo \emph{overhead} en la grabación de registro de un programa \emph{multithreaded} en un uniprocesador con la velocidad y la escalabilidad de ejecución de un programa en un multiprocesador. La idea básica es que se peude usar un mecanismo más simple y rápido de grabación y repetición en un solo procesador y aún así lograr la escalabilidad ofrecida por múltiples núcleos, utilizando una ejecución adicional para paralelizar la grabación y la repetición de una aplicación. La meta es que una ejecución en un solo procesador sea tan rápida como una ejecución en paralelo tradicional, pero mantener la facilidad de registro de la ejecución \emph{multithreaded} de un solo procesador.

\paragraph{\textnormal{\textbf{Uniparallelism}}}
Es una técnica para lograr los beneficiones de ejecución en un solo procesador al mismo tiempo que se permite a la aplicación escalar con el aumento de procesadores. Una ejecución uniparalela consiste de ejecución \emph{thread-parallel} y ejecución \emph{epoch-parallel} del mismo programa; esto permite el uso de técnicas que corren solo en un uniprocesador. A diferencia de una ejecución tradicional \emph{thread-parallel} que escala con el número de núcleos corriendo diferentes \emph{threads} en diferentes núcleos, una ejecución \emph{epoch-parallel} logra escalabilidad de una manera diferente, corriendo diferentes epochs (segmentos de tiempo) de la ejecución en múltiples núcleos. Por lo tanto, ejecución \emph{epoch-parallel} requiere de la habilidad de predecir el estados del programa futuros; tales predicciones son generadas corriendo la segunda ejecución \emph{thread-parallalel} concurrentemente. Consecuentemente, para cargas de trabajo intensivas en CPU, la ejecución uniparalela requiere del doble del número de núclos de una ejecución tradicional, conduciendo a un aumento de aproximadamente 100\% de la utilización de CPU y energía. Uniparalalelismo mejora el rendimiento en dos casos: (1) si una carga de trabajo no es intensiva en CPU o si la aplicación no puede escalar y utilizar todos los núcleos eficientemente en una computadora \emph{multicore}, el costo de uniparalelismo puede ser mucho menos que del 100\%(típicamente menos de 20\%). (2) cuando la propiedad que se proporciona es más del doble de costosa en un multiprocesador que en un uniprocesador, es más eficiente en términos de tiempo y energía correr la aplicación dos veces con uniparalelismo que proporcionar la propiedad directamente en la versión multiprocesador de la aplicación.

\paragraph{\textnormal{\textbf{Design Overview}}}
La meta de DoublePlay es la de grabar eficientemente la ejecución de un proceso o group de procesos que corren en un multiprocesador tal que la ejecución pueda ser repetida de forma determinista luego todas las veces necesarias. DoublePlay corre dos ejecuciones simultaneas del programa que se está grabando. La ejecución \emph{thread-parallel}, corre múltiples \emph{threads} concurrentemente en los núcleos asignados para ello. DoublePlay particiona la ejecución \emph{thread-parallel} en segmetos de tiempo llamados \emph{epochs}. Al inicio de cada epoch, DoublePlay crea un punto de verificación \emph{copy-on-write} del estado de la ejecución \emph{thread-parallel}. La ejecución \emph{epoch-parallel} corre cada epoch en uno de los núcleos asignados para ello. Todos los \emph{threads} de un epoch dado corren en el mismo núcleo, lo que simplifica la tarea de repetir de forma determinista el resultado de la ejecución. Durante la grabación, DoublePlay guarda tres elementos que son suficientes para garantizar que la ejecución de un proceso puede ser repetido de forma determinista en el futuro. (1) Graba el estado inicial del proceso al inicio de la grabación. (2) DoublePlay graba el orden y los resultado de los \emph{system calls}, señales y sincronizaciones de bajo nivel en GNU \texttt{libc}. (3) graba la planificación de la ejecución del \emph{thread} de la ejecución \emph{thread-parallel}. Las dos ejecuciones puede ser vistas de la siguiente forma. La ejecución \emph{epoch-parallel} es la ejecución real del program que está siendo grabado. La ejecución \emph{epoch-parallel} corre en un solo núcleo. DoublePlay puede usar el mecanismo de repetición determinista uniprocesador para grabar y reproducir su ejecución. La ejecución \emph{thread-parallel} permite a la ejecución \emph{epoch-parallel} escalar de acuerdo al número de núcleos. La ejecución \emph{thread-parallel} proporciona un \emph{hint} en cuanto a lo que el estado futuro de la ejecución del proceso será en cada transición de epoch. Mientras que este \emph{hint} sea correcto, el estado del proceso al inicio de cada epoch en la ejecución \emph{epoch-parallel} coincidirá con el estado del proceso al final del epoch previo. Esto significa que los epochs se pueden juntar para forma una sola y natural ejecución del proceso. Si el estado de la ejecución \emph{epoch-parallel} ha divergido del estado de la ejecución \emph{thread-parallel}, DoublePlay aplasta (\emph{squaches}) la ejecución de todos los epochs subsecuentes para ambas ejecuciones. Restaura el estado de cada ejecución \emph{thread-parallel}  al punto de verificación en el inicio de cada epoch y reinicia ambas ejecuciones desde este punto. Las salidas no pueden ser externalizadas hastas que todos los epochs previos han sido encontrados como libres de divergencia. DoublePlay usa \emph{online  replay} para reducir la frecuencia de tales divergencias y sus resultantes atrasos. La única situacio4n en que la ejecución \emph{thread-parallel} y la ejecución \emph{epoch-parallel} podrían divergir es cuando el programa contiene un \emph{data race} y dos \emph{threads} se ejecutan sin sincronizar, haciendo que operaciones entren en conflicto en un espacio de memoria compartido. En cualquier momento subsecuente, DoublePlay puede repetir una ejecución grabada al (1) restaurar el estado inicial del proceso grabado, (2) repitiéndolo en un sólo núcleo usando los \emph{sistem calls} registrados, señales y operaciones de sincronización y (3) usa la misma planificación de la ejecución del \emph{thread} que fue usada durante la ejecución \emph{epoch-parallel}.

\paragraph{\textnormal{\textbf{Implementación}}}
La implementación de DoublePlay aprovecha el trabajo previo de Respec para proveer repetición \emph{online} determinista. Respec asegura que dos ejecuciones concurrentes del mismo proceso son externamente deterministas, lo que significa que las dos ejecuciones ejecutan los mismo \emph{system calls} en el mismo orden y que el estado del programa de los dos procesos es idéntico al final de cada epoch de ejecución. Respec sólo asegura determinismo externo mientras dos procesos se ejecutan al mismo tiempo. No aborda repetición determinista de un proceso luego de que la ejecución original se completa. \textbf{Supporting offline replay:} DoublePlay hace varias mejoras en la infraestructura básica de Respec con el fin de soportar repetición \emph{offline}. \textbf{Enabling concurrent epoch execution:} DoublePlay hace múltiples copias de la ejecución \emph{thread-parallel} llamando la primitiva de \emph{multi-threaded fork} antes de inicar la ejecución la ejecución de cada epoch individual. Esta primitiva crea un nuevo proceso cuyo estado es idéntico al de la ejecución \emph{thread-parallel} en el punto de su ejecución. Cada vez que un nuevo proceso es creado, DoublePlay no le permite iniciar su ejecución, sino que en lugar de esto, lo pone en un \emph{epoch queue} ordenada por el tiempo de creación del proceso. El \emph{scheduler} de DoublePlay es el responsable de decidir cuando y donde cada proceso va a correr. No hay garantía que la ejecución de un epoch finalizará en orden, debido a que algunos epochs son más cortos que otros . DoublePlay usa un algoritmo adaptativo para variar la longitud de los epochs. Aunque los epochs pueden finalizar no ordenados, DoublePlay asegura que ellos hacen \emph{commit} o \emph{rollback} en orden secuencial. Cuando un epoch completa su ejecución, DoublePlay realiza un \emph{divergence check} comparando su memoria y registros de estado con los del punto de verificación asociado con el próximo epoch. Cuando la verificación pasa, DoublePlay le permite al proceso salir y asigna su procesador a otro epoch. Cuando falla, DoublePlay finaliza todos los \emph{threads} que ejecutan el epoch actual y cualquier epoch futuro en la ejecución \emph{epoch-parallel}, así como todos los \emph{threads} de la ejecución \emph{thread-parallel}. \textbf{Replaying thread schedules:} DobulePlay garantiza repetición \emph{offline} determinista al ejecutar cada epoch en un solo núcleo usando la misma planificación de \emph{thread} que fue usada durante la grabación de la ejecución \emph{epoch-parallel}. Una estrategia es usar el mismo planificador determinista durante la ejecución \emph{epoch parallel} y la repetición \emph{offline}. La segunda estrategia es la de registrar las decisiones de planificación hechas durante la ejecución \emph{epoch parallel} y repetir aquellas deciciones de manera determinista durante la repetición \emph{offline}. Para la primera estrategia, se asigna una prioridad estricta a cada \emph{thread} basado en el orden en que los \emph{threads} fueron creados. DoublePlay siempre escoge el \emph{thread} con la prioridad más alta que preserve el orden total de los \emph{system calls} y el orden parcial de las operaciones de sincronización. Para permitir apropiaciones \emph{preemptions} se implementa la segunda estrategia para repetir la planificación de los \emph{threads} de forma determinista, la cual es la de registrar las apropiaciones que ocurren durante la ejecución \emph{epoch parallel} y repetir esas decisiones de forma determinista durante la repetición \emph{offline}. \textbf{Offline replay:} DoublePlay graba los \emph{system calls} y las operaciones de sincronización ejecutadas durando un epoch en un conjunto de archivos de bitácora. Luego de que cada epoch es \emph{committed}, DoublePlay marca las entradas que pertenecen a cada epoch como elegibles para ser escritas en disco. Luego escribe los registros marcados de forma asincrónica mientras otros epochs se ejecutan. Nótese que DoublePlay solo tiene que grabar los resultados de operaciones de sincronización o \emph{system calls}, ya que los argumentos a esas llamadas serán reproducidas de forma determinista por cualquier proceso de repetición. DoublePlay guarda el estado inicial del proceso cuando la grabación inicia. Para realizar una repetición \emph{offline}, inicia desde esta copia inicial. DoublePlay corre la repetición \emph{offline} en un solo procesador y usa un algoritimo de planificación (el de la sección anterior) para restringuir el orden de la ejecución del \emph{thread} para el proceso de repetición \emph{offline}. Cuando un \emph{thread} de repetición \emph{offline} ejecuta un \emph{system call} o una operación de sincronización, DoublePlay retorna los resultados grabados en su archivo de bitácora. DoublePlay solamente ejecuta \emph{system calls} que modifican el espacio de direcciones del processo como \texttt{mmap2} y \texttt{clone}. DoublePlay entrega las señales grabadas en el mismo punto en la ejecución del proceso en la que fueron entregadas durante la grabación. \textbf{Forward recovery:} Una vez que se vió que la ejecución \emph{epoch-parallel} como la que se tenía que ser grabada, fue claro que el estado de su ejecución en el momento de un fallo de verificación de divergencia es un estado válido de ejecución que puede ser reproducido \emph{offline} de forma determinista. Por lo tanto, DoublerPlay puede usar el estado del proceso \emph{epoch-parallel} en el momento de un fallo de verificación de divergencia como un punto de verificación de donde reiniciar la ejecución. A este proceso se le llama recuperación hacia adelante (\emph{forward recovery}). DoublePlay registra una operación para deshacer cada \emph{system call} que modifica el estado del kernel, así recuperación hacia adelante (o normal) puede devolver el estado del kernel al aplicar las operaciones para deshacer. \emph{Forward recovery} garantiza que DoublePlay haga progreso hacia adelante incluso cuando una verificación de divergencia falla. Todo el trabajo hecho por la ejecución \emph{epoch-parallel} hasta la verificación de divergencia, incluyendo al menos un \emph{data race}, será preservado. En el peor caso, cada epoch puede contener \emph{data races} frecuentes y verificaciones de divergencia que siempre fallen. \emph{Looser divergence checks:} con la implementación de \emph{forward recovery}, se decidió que realizar verificaciones estrictas de divergencia no era lo mejor. Se modificó DoublePlay par soportar tres tipos de formas más relajadas de verificación de divergencia en un epoch. (1) si el búfer circular de un \emph{thread} contiene un \emph{system call} sin ningún efecto hacia el exterior de este \emph{thread}, se permite omitir el registro extra en el búfer. (2) si un \emph{thread} ejecuta un \emph{system call} que produce una salida para un dispositivo externo, como una pantalla o una red, se permite que la ejecución \emph{epoch-parallel} ejecute el mismo \emph{system call} con diferente salida. (3) si un \emph{thread} ejecuta un conjunto de operaciones de sincronización \emph{self-canceling} o \emph{system calls} durante la ejecución \emph{thread-parallel}, entonces todos los miembros de ese conjunto pueden ser saltados. Beneficios de \emph{looser divergence}. (1) la ejecución \emph{epoch parallel} puede correr por más tiempo antes que se necesite un \emph{rollback}. (2) a veces un \emph{rollback} puede ser evitado en conjunto cuando la divergencia del estado proceso del proceso es transitoria. \textbf{Reverse scheduling:} la idea detrás de \emph{reverse scheduling} es la de intentar evitar \emph{rollbacks} cuando una verificación de divergencia falla al encontrar una planificación diferente cuya ejecución cause que la verificación pase. Así, cuando una verificación falle, DoublePlay corre otra ejecución \emph{epoch-parallel} del epoch fallido en el procesador asignado para ese epoch, pero usa las prioridades de planificación opuestas de las que se usaron por la ejecución fallida. Esto es, el último \emph{thread} creado tiene la prioridad más alta, no la más baja. La idea es que si hay un solo \emph{data race} en el epoch, entonces tanto la planificación normal o la reversa son muy probables a reproducir el mismo estado del programa producido por la ejecución \emph{thread parallel}. Si una segunda ejecución pasa la verificación de divergencia, el epoch es \emph{committed} y ningún \emph{rollback} ocurre. La planificación reversa del \emph{thread} es grabada en la bitácora de DoublePlay asi puede ser usada también durante la repetición.


\section{¿Cuál es el problema que plantea el \textit{paper}?}
La repetión determinista en multiprocesadores es una tarea retadora de implementar eficientemente debido a la necesidad de reproducir el orden o los valores que son leídos por operaciones de memoria compartida en múltiples \emph{threads}.

\section{¿Por qué el problema es interesante o importante?}
La repetición determinista funciona registrando todos los eventos no-deterministas durante la fase de grabación, luego reproduce estos eventos durante la etapa de repetición. En uniprocesadores, los eventos no-deterministas ocurren relativamente con poca frecuencia, por este motivo registrarlos y repetirlos añade poco \emph{overhead}. Si hay múltiples \emph{threads} corriendo en el uniprocesador, estos puede ser repetidos a un bajo \emph{overhead} registrando y reproduciendo la planificación del \emph{thread}. Sin embargo, en multiprocesadores los accesos a memoria compartida añaden una fuente de no-determinismo de alta frecuencia, y registrar y repetir estos accesos puede reducir drásticamente el rendimiento. Aunque se han propuesto varias alternativas para reducir el \emph{overhead} de la grabación y la repetición de programas \emph{multithreaded}, en memoria compartida, y con múltiples procesadores, muchos se quedan cortos en alguna forma u otra. Algunos enfoques requiren hardware personalizado, otras son muy lentos y otros sacrifican la garantía de poder reproducir la ejecución grabada sin la posibilidad de una búsqueda prohibitivamente larga. 

\section{¿Qué otras soluciones se han intentado para resolver este problema?}
\begin{itemize}
    \item Muchos sistemas de repetición uniprocesador: IGOR, Hypervisor, Mach 3.0 Replay, DejaVu, ReVirt y Flashback.
    \item SMP-ReVirt: repetición en multiprocesador. Usa protección de página para registrar solo el orden de accesos conflictivos a páginas de memoria.
    \item Una forma de reducir el \emph{overhead} de registro en multiprocesadores es añadiendo soporte de hardware. La estrategia más común es la de modificar el mecanismo de coherencia de caché para registrar la información necesaria para inferir el orden de accessos de memoria compartida.
    \item Investigadores también han intentado reducir el \emph{overhead} de registro relajando la definición de repetición determinista. En lugar de requerir que todas las instrucciones retornen los mismos datos que se retornaron en la corrida original, estos enfoques proporcionan garantías ligeramente más débiles las cuales aún soportan los usos propuestos para repetición.
    \item Repetición determinista basada en búsqueda. En lugar de registrar suficientes datos para repetir rápidamente una ejecución, estos sistemas graban un subconjunto de información, luego usan esa información para guiar la búsqueda de una ejecución equivalente. 
    \item Asegurar que toda la comunicación inter-\emph{thread} sea determinista para una entrada dada. Este enfoque elimina la necesidad de registrar el orden de accesos a memoria compartida.
    \item DoublePlay aplica ideas de investigaciones en uso de especulación para correr aplicaciones en paralelo.
\end{itemize}

     
\section{¿Cuál es la solución propuesta por los autores?}
DoublePlay, una nueva forma de garantizar repetición eficiente en multiprocesadores de fácil acceso. La idea clave es que se puede usar los mecanismos simples y eficientes de grabación y repetición de un solo procesador y aún así lograr la escalabilidad ofrecida por múltiples núcleos, usando una ejecución adicional para paralelizar la grabación y repetición de la aplicación. DoublePlay divide múltiples \emph{threads} en segmentos de tiempo en un solo procesador, luego corre múltiples intervalosdel programa concurrentemente en procesadores separados. Esta estrategia, a la que se llama uniparalelismo, hace que el registro sea mucho más fácil porque cada epoch corre en un solo procesador y diferentes epochs operan en diferentes copias de la memoria. Asi, en lugar de registrar el orden de accesos a la memoria compartida, se necesita solo registrar el order en que los \emph{threads} fueron divididos en segmentos de tiempos en el procesador. DoublePlay corre una ejecución adicional del programa en múltiples procesadores para generar puntos de verificación de manera que los epochs corran en paralelo. 

\section{¿Qué tan exitosa es esta solución?} 
\paragraph{Record and replay performance:} La disponibilidad de núcleos no utilizados impacta significativamente el \emph{overhead} usado por DoublePlay durante la grabación. Si hay suficientes núcleos sin utilizar, DoublePlay añade poco \emph{overhead} en el momento ejecución de la grabación de una aplicación. En promedio, 2 \emph{worker threads} añaden alrededor de 15\% \emph{overhead}. El \emph{overhead} aumenta gradualmente a 28\% con 4 \emph{threads}. Si todos los núcleos puede usarse productivamente por la aplicación, entonces DoublePlay incurre en un mayor \emph{overhead} debido a que ejecuta la aplicación dos veces durante la grabación, y esto usa los núcleos que pudieron haber sido usados por la aplicación. Cuando se compara con una aplicación configurada para usar el mismo número de núcleos que DoublePlay, DoublePlay añade aproximadamente 100\% de \emph{overhead} a aplicaciones intensivas en CPI que puede escalar a 8 núcleos. Usos de DoublePlay: (1) Aplicaciones que no pueden escalar eficientemente para usar todos los núcleos en una máquina. (2) Sitios que están dispuestos a dedicar núcleos extra para proporcionar repetición determinista. (3) Aplicaciones que comparten datos freuentemente entre núcleos. En comparaciones (\emph{benchmarks}) intensivas en CPU, la repetición \emph{offline} de DoublePlay toma al menos el mismo tiempo que la ejecución de la aplicación en un solo \emph{thread}. 

\paragraph{Forward recovery and loose replay:} la optimización de \emph{loose replay} reduce la frecuencia de \emph{rollbacks}. La eliminación de \emph{rollbacks} mejora el tiempo de ejecución de 6\% en la ejecución original con 2 \emph{threads} a 13\% con 4 \emph{threads}. Mientras que \emph{forward recovery} y \emph{loose replay} fueron usualmente exitosos en reducir los \emph{rollbacks} y preservar el trabajo hecho durante un epoch fallido, parecen ser más beneficiosos para aplicaciones intensivas en CPU con duraciones más largas epoch.