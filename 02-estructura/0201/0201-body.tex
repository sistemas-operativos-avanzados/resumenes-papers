%Los sistemas operativos(SO) definen una interfase entre aplicaciones y recursos físicos. Desafortunadamente, esta interfase puede limitar significativamente el rendimiento y la libertad de implementación de las aplicaciones. Tradicionalmente, los SO esconden información acerca de los recursos de la máquina detrás de abstracciones de alto nivel como procesos, archivos, espacios de direcciones y procesos de intercomunicación. Estas abstracciones definen una máquina virtual en donde las aplicaciones se ejecutan; su implementación no puede ser reemplazada o modificada por aplicaciones no confiables. ``Hardcodear'' la implementación de estas abstracciones es inapropiado por: le niega a las aplicaciones las ventajas de las optimizaciones de dominio específico, se desalienta a cambiar las implementacione de abstracciones actuales y reestringuen la flexibilidad de constructores de aplicaciones dado que nuevas abstracciones son difíles de agregar.

En la arquitectura \textbf{exokernel} las abstracciones tradicionales como memoria virtual y comunicación entre procesos, son implementadas enteramente a nivel de aplicación por \textit{software} no confiable. In esta arquitectura, un kernel mínimo multiplexa los recursos de \textit{hardware} disponible de forma segura. La librería de SO que trabaja por encima de la interfase de \textit{exokernel} implementa abstracciones de mayor nivel. Los escritores de aplicaciones seleccionan librerías o implementan las suyas. Nuevas implementaciones de librerías de SO son incorporadas re-enlazando los ejecutables de aplicación. \textit{Exokernel} provee una control a través de una interfase de bajo nivel. Un diseñador \textit{exorkernal} tiene una meta: separar la protección de la administración. Para esto se ``exportan'' recursos de \textit{hardware} en lugar de emularlos. Las tres técnicas para exportar recursos de forma segura son: \textit{secure binding, visible resource revocation \textnormal{y} 
abort protocol}.

\paragraph{\textnormal{\textbf{The Cost of fixed high-level abstraction}}}
Abstracciones en SO tradicionales tienden a ser muy generales, intentan proveer todas las funciones que se necesitan a todas las aplicaciones. \underline{Las abstracciones de alto nivel}: (1) dañan el rendimiento porque no hay una forma de implementar una abstracción que sea la mejor para todas las aplicaciones. Obligan al SO a tener que hacer decisiones de direcciones de espacio y cargas de trabajo que pueden penalizar a las aplicaciones. (2) Escoden información a las aplicaciones, esto hace que sea difícil o imposible para las aplicaciones implementar sus propias abstracciones de gestión de recursos. (3) limitan la funcionalidad de aplicaciones porque ellas son las únicas interfases disponibles entre aplicaciones y recursos de \textit{hardware}.

\paragraph{\textnormal{\textbf{Exokernels: An End-to-End Argument}}}
Las aplicaciones conocen mejor que los sistemas operativos cuáles son sus metas en decisiones de gestión de recursos y por lo tanto, se les debería dar tanto control como sea posible sobre estas decisiones. \textit{Exokernel} permite que las abstracciones tradicionales sean implementadas enteramente a nivel de aplicación. Esta arquitectura consiste de una capa fina que multiplexa  \footnote{Combinación de dos o más canales de comunicación en un sólo medio de transmisión.} y exporta recursos físicos de forma segura a través de un conjunto de primitivas de bajo nivel. Librerías de SO las cuales usan la interfase de bajo nivel de \textit{exokernel}, implementan abstracciones de alto nivel y pueden definir implementaciones especiales que pueden cumplir mejor con las metas de rendimiento y funcionacilidad de las aplicaciones. \textbf{Library Operating Systems:} las aplicaciones que se ejecutan en \textit{exokernel} puede reemplazar y extender libremente librerías de SO sin privilegios especiales, lo que simplifica el desarrollo y el agregar nuevas características. \textbf{Exokernel design:} al separar la protección de la administración se realizan 3 tareas: (1) rastreo del propietario de los recursos, (2) asegurar protección al custodiar todo el uso del recurso y (3) revocar acceso a los recursos. Las tareas se logran por 3 técnicas: \textit{secure binding, visible revocation \textnormal{y} abort protocol}. \textbf{Principios de diseño:} Exposición segura de \textit{hardware}: sólo gestiona recursos en la medida requerida por la protección. Exponer la asignación: los recursos no son asignados de forma implícita, la librería de SO participa en la asignación. Exponer nombres: exportar nombres físicos (más eficientes). Exponer revocación: un protocolo de revocación de recursos visible para las librerías de SO. \underline{Policy}: \textit{exokernel} incluye un política para arbitrar entre librerías de SO competidoras: determinar la importancia y los recursos compartidos. \textbf{Secure bindings}: mecanismo de protección que desacopla la autorización del uso real del recurso. Son operaciones simples que el kernel ejecuta rápido y se llevan a cabo durante el tiempo de enlace (\textit{bind time}). \textit{Software} a nivel de aplicación puede usar primitivas de \textit{hardware (TLB entry)} o \textit{software} para soportar \textit{secure bindings}. Se implementa por: \textit{hardware}, \textit{software caching} y descargando código de aplicación. \textbf{Visible Resource Revocation:} una vez que los recursos son enlazados tiene que haber una forma de reclamarlos y romper su \textit{secure binding}. \textit{Exokernel} usa revocación visible -- le informa a las aplicaciones y estas pueden reaccionar. \textbf{The Abort Protocol:} si una librería de SO falla en responder rápido los enlances seguros (\textit{secure bindings}) necesitan ser rotos ``a la fuerza''. Estas pérdidas forzadas de un recurso se registran en un vector de reposición que se puede usar para actualizar los mapeos hacia ese recurso.

\paragraph{\textnormal{\textbf{Aegis: an Exokernel}}}
Aegis: implementación de un software que sigue la arquitectura de exokernel. Exporta el procesador, memoria física, TLB, excepciones e interrupciones.
 

\section{¿Cuál es el problema que plantea el \textit{paper}?}
La interfase que definen los SO entre aplicaciones y recursos puede limitar significativamente el rendimiento y la libertad de implementación de las aplicaciones. Tradicionalmente, los SO esconden información acerca de los recursos de la máquina detrás de abstracciones de alto nivel como procesos, archivos, espacios de direcciones y procesos de intercomunicación. Estas abstracciones definen una máquina virtual en donde las aplicaciones se ejecutan; su implementación no puede ser reemplazada o modificada por aplicaciones no confiables. ``Hardcodear'' la implementación de estas abstracciones es inapropiado por: le niega a las aplicaciones las ventajas de las optimizaciones de dominio específico, se desalienta a cambiar las implementacione de abstracciones actuales y reestringuen la flexibilidad de constructores de aplicaciones dado que nuevas abstracciones son difíles de agregar.

\section{¿Por qué el problema es interesante o importante?}
Porque al delegar a las aplicaciones la implementación de estas abstracciones se puede tener un mejor control sobre la ejecución y el rendimiento de estas abstracciones.  

\section{¿Qué otras soluciones se han intentado para resolver este problema?}
Otros artículos y proyectos han discutido la necesidad de kernels extensibles y flexibles:
\begin{itemize}
    \item Hydra fue el más ambicioso sistema en tener una separación entre la política y mecanismo del kernel como uno de sus principios centrales.
    \item VM/370: exporta la interfase de \textit{hardware}. Por encima de esta interfase se soportan un número de máquinas virtuales en donde sistemas operativos radicalmente diferentes pueden ser implementados. Esta flexibilidad se provee a partir de la virtualización de toda la máquina base.
    \item Microkernels: similitud con exokernels en que están diseñados para incrementar la flexibilidad. Diferencia en que los exorkernels ponen la interfase del kernel mucho más cerca al hardware, lo cual brinda mayor flexibilidad.
    \item SPIN: un microkernel qeu permite a las aplicaciones hacer decisiones sobre políticas por medio de descargas seguras de extensiones al kernel. A diferencia de SPIN, la meta de exokernel es obtener flexibilidad y rendimiento por medio de la exposición de primitivas de bajo nivel en lugar de extender SO tradicionales en una forma segura.
    \item SPACE: un ``submicro-kernel'' que provee solamente abstracciones de bajo nivel definidas por la interfase de arquitectura y de trampa. 
\end{itemize}

\section{¿Cuál es la solución propuesta por los autores?}
La arquitectura \textit{exokernel}. Un \textit{exokernel} multiplexa los recursos de \textit{hardware} disponibles entre las aplicaciones de forma segura. Las librerías de SO, las cuales trabaajan por encima de la interfase de bajo nivel de \textit{exokernel}, implementan abstracciones de alto nivel y pueden definir implementaciones para propósitos especiales las cuales cumplan con las metas de rendimiento y funcionalidad de las aplicaciones de mejor forma. Esta arquitectura está motivada por una simple observación: entre más bajo sea el nivel de la primitiva, mayor será la eficiencia en su implementación. Para lograr esta interfase de bajo nivel, \textit{exokernel} separa la gestión de la implementación. Para hacer esta separación eficiene se usa \textit{secure bindings}, implementados usando mecanismos de \textit{hardware}, \textit{software caches} o descargando código.

\section{¿Qué tan exitosa es esta solución?} 
Se implementa un prototipo de un sistema operativo tipo \textit{exokernel} basado en \textit{secure bindings}, revocación visible y protocolos de anulación (\textit{abort}). Aegis es la implementación del \textit{exokernel} y ExOS un librería de SO no confiable (\textit{untrusted}). Los experimientos con estos prototipos demostraron las siguiente hipótesis:
\begin{enumerate}
    \item la simplicidad y el número limitado de primitivas \textit{exokernel} les permite que sean implementadas muy eficientemente. Las mediciones en Aegis mostraron que sus primitivas básicas son substancialmente más eficientes que las primitivas generales provistas por en Ultrix. Además, el rendimiento de Aegis es mejor o similar con implementaciones recientes de alto rendimiento de despacho de excepciones y control de transferencia de primitivas.
    \item Debido a que las primitivas de \textit{exokernel} son rápidas, la multiplexación segura de bajo nivel de recursos de hardware puede ser implementada de forma eficiente. Por ejemplo, Aegis multiplexa recursos como el procesador, memoria y de red más eficientemente que las implementaciones más recientes.
    \item Abstracciones tradicionales de SO pueden ser implementadas eficientemente a nivel de aplicación. Por ejemplo, la memoria virtual de nivel de aplicación y las primitivas de comunicación interprocesos en ExOS son mucho más rápidas que las de Ultrix y de las implementaciones más recientes.
    \item Las aplicaciones pueden crear implementaciones especiales de las abstracciones simplemente modificando una librería. Se implementaron variantes de abstracciones fundamentales de SO como la de comunicación interproceso, memoria virtual y \textit{schedulers} obteniendo mejoras substanciales en funcionalidad y rendimiento.
\end{enumerate}

