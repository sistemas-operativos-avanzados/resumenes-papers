Los sistemas basados en $\mu-$kernel han sido construidos desde antes que el término fuera introducido. Tradicionalmente, la palabra ``kernel'' se usa para denotar la parte el sistema operativo es necesaria y común para todo el otro software. La idea básica del enfoque $\mu-$kernel es el de minimizar esta parte, por ejemplo, implementar fuera del kernel lo que sea posible.

Aunque se ha invertido mucho esfuerzo en la construcción de $\mu-$kernel, el enfoque no ha sido aún aceptado de forma general. Esto debido al hecho de que la mayoría de $\mu-$kernels no tiene un rendimiento suficientemente bueno. La ausencia de eficiencia también reestringue la flexibilidad, dado que mecanismos y princpios importantes no se pueden poner en práctica debido al pobre rendimiento. Se cree que el modo de \textit{user-kernel} aumentado y los cambios en el espacio de direcciones con los responsables.

\paragraph{\textnormal{\textbf{Some $\mu-$Kernel Concepts}}} 
Un criterio puede es tolerado dentro de $\mu-$kernel solo si al moverlo fuera del kernel, permitiendo que las implementaciones compitan, evitaría la implementación de una funcionalidad requerida por el sistema. Un requerimiento inevitable para tales sistemas es que un programador debe ser capaz de implementar un sub-sistema $S$ de tal forma que no pueda ser perturbado o corrompido por otros sub-sistemas $S'$. \underline{Principio de independencia:} $S$ puede garantizar independencia de $S'$. El segundo requerimiento es que otros sub-sistemas puedan confiar de estar garantías $\rightarrow$ \underline{Principio de integridad:} tiene que haber una forma para que $S_1$ se puede dirigir a $S_2$ y establecer un canal de comunicación que no pueda ser corrompido o interferido por $S'$. \textbf{Address Spaces:} a nivel del \textit{hardware} un espacio de direcciones es un mapeo que asocia cada página virtual con un marco de página física o bien la marca como ``no accesible''. Los mapeos son implementados por \textit{hardware} TLB y tablas de páginas. $\mu-$kernel tiene que ocultar el concepto de \textit{hardware} de espacio de direcciones sino de otro forma , la implementación de protección seria imposible. Se debe permitir la implementación de esquemas arbitrarios de protección (y de no-protección) por encima de $\mu-$kernel. Debería ser simple y similar al concepto de \textit{hardware}. La idea básica es la de brindar construcciones recursivas de espacios de direcciones por fuera del kernel. Existe un espacio direcciones $\sigma_0$ que representa la memoria físicay que es controlada por el primer sub-sistema $S_0$. Cuando el sistema inicia todos los otros espacios de memoria están vacíos. Para construir y mantener más espacios de memoria por encima de $\sigma_0$, $\mu-$kernel provee estas tres operaciones: (1) \textit{Grant}: el dueño de un espacio de memoria puede otorgar (\textit{grant}) una de sus páginas a otro espacio, siempre y cuando el destinatario acepte. La página se remueve del espacio de direcciones del que otorga\footnote{Restricción: Solamente puede otorgar páginas a las cuales tiene acceso} y se le asigna al destinatario. (2) \textit{Map}: El dueño de un espacio de direcciones puede mapear cualquiera de sus páginas\footnote{Restricción: solo puede mapear páginas a las que tenga acceso.} dentro de otro espacio de direcciones, si el destinatario acepta. Al final, la página puede ser accedida en ambos espacios de direcciones. (3) \textit{Flush}: el dueño de un espacio de memoria puede liberar (\textit{flush}) cualquiera de sus páginas. La página que se libera se mantiene accesible in el espacio de direcciones de quién la liberó pero es removida de todo los otros espacios de direcciones que hayan recibidio directa o indirectamente la página de quién la liberó (el \textit{flusher}). \underline{I/O:} el control de los derechos de acceso de I/O y controladores de dispositivos se lleva a cabo por gestionadores de memoria y \textit{pagers} por encima de $\mu-$kernel. \textbf{Threads and IPC:} Un hilo es una actividad que se ejecuta dentro un espacio de direcciones. Un hilo $\tau$ se caracteriza por un conjunto de registros, un puntero de pila e información de estado. El estado del hilo también incluye el espacio de memoria $\sigma^{(\tau)}$ en donde $\tau$ se está ejecutando. Esta asociación dinámica o estática a un espacio de direcciones es la razón decisiva para incluir el concepto de hilos en $\mu-$kernel. Para prevenir espacios de direcciones corrompidos, todos los cambios en el espacio de direcciones de un hilo debe ser controladas por el kernel. Esto implica que $\mu-$kernel incluye la noción de algún $\tau$ el cual representa la actividad mencionada anteriormente. La comunicación entre espacios de direcciones (IPC) debe de ser soportada por $\mu-$kernel. El método clásico es transferir mensajes entre hilos por medio de $\mu-$kernel. \underline{Interrupciones:} abstracción: mensajes IPC. El \textit{hardware} es considerado como un conjunto de hilos que tienen \textit{ids} especiales y envían mensajes vacíos hacia hilos de \textit{software} asociados. Transformar interrupciones a mensajes lo realiza el kernel pero $\mu-$kernel no se especializa en interrupciones específicas de dispositivos. \textbf{Unique Identifiers}: $\mu-$kernel provee identificadores únicos para hilos, tareas o canales de comunicación. \textit{Uids} son requeridos para una comunicación local confiable y eficiente.

\paragraph{\textnormal{\textbf{Flexibility}}}
Algunas aplicaciones que típicamente pertenecen al SO básico pero que pueden ser implementas por encima de $\mu-$kernel son: Gestores de memoria, \textit{pagers}, asignación de recursos multimedia, controladores de dispositivos, cache de segundo nivel y TLB, comunicaciones remotas, servidores Unix. Lo único que no se puede implementar por encima de estas abstracciones es la arquitectura del procesador, registros, cache de primer nivel y TLBs de primer nivel. 

\paragraph{\textnormal{\textbf{Performance, Facts \& Rumors}}}
\textit{Kernel-user switches:} comparado con el mínimo teórico, \textit{user-kernel mode switches} son costoso en algunos procesadores. Por otro lado, en comparación con otros kernels existentes se pueden mejorar de 6 a 10 veces por medio de una construcción apropiada de $\mu-$kernel. \textit{Kernerl-user mode switches} no son un problema conceptual serio pero si uno de implementación. \textit{Address Space Switches:} si se construyen adecuadamente no soy muy costosos, menos de 50 ciclos en procesadores modernos. En un procesador de 100 MHz, el costo heredado de \textit{switches} de espacios de direcciones puede ser ignorado aproximandamente hasta 100,000 \textit{switches} por segundo. Optimizaciones especiales, como ejecución de servidores dedicados en espacios de kernel, son superfluos. Este contexto costoso de \textit{switching} en algunos $\mu-$kernels existentes se debe a la implementación y no es causado por problemas inherentes con el concepto. \textit{Thread Switches and IPC:} IPC puede ser implementado lo suficientemente rápido para manejar también interrupciones de \textit{hardware} por medio de este mecanismo. \textbf{Memory Effects:} la hipótesis que la arquitectura $\mu-$kernel inherentemente conduce a degradación de la memoria del sistema no está justificado. Por el contrario, las mediciones mencionadas apoyan la hipótesis que $\mu-$kernels construidos apropiadamente van a evitar automáticamente la degradación de la memoria del sistema en Mach.\footnote{Implementación de un $\mu-$kernel.}




\section{¿Cuál es el problema que plantea el \textit{paper}?}

\section{¿Por qué el problema es interesante o importante?}

\section{¿Qué otras soluciones se han intentado para resolver este problema?}
     
\section{¿Cuál es la solución propuesta por los autores?}

\section{¿Qué tan exitosa es esta solución?} 